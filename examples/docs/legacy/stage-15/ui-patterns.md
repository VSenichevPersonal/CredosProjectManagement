# UI Паттерны проекта IB Compliance Platform

## Паттерн редактирования: Toggle Edit Mode with In-Place Editing

### Описание

Основной паттерн редактирования в проекте - **Toggle Edit Mode with In-Place Editing** (Переключаемый режим редактирования с редактированием на месте).

Этот паттерн используется для всех карточек просмотра и редактирования сущностей (требования, организации, меры защиты, риски и т.д.).

### Принципы

1. **Единая карточка для просмотра и редактирования** - нет отдельных страниц или модальных окон
2. **Явное переключение режимов** - кнопка "Редактировать" переключает карточку в режим редактирования
3. **Редактирование на месте** - поля ввода заменяют статичный контент в том же месте
4. **Сохранение контекста** - пользователь остается на той же странице, видит окружающую информацию
5. **Безопасность** - случайные изменения невозможны, требуется явное переключение режима

### Структура компонента

\`\`\`tsx
export function EntityDetailPage({ id }: { id: string }) {
  const [entity, setEntity] = useState<Entity | null>(null)
  const [isEditing, setIsEditing] = useState(false)
  const form = useForm<EntityFormData>()

  // Режим просмотра
  if (!isEditing) {
    return (
      <div>
        <header>
          <h1>{entity.title}</h1>
          <Button onClick={() => setIsEditing(true)}>Редактировать</Button>
        </header>
        <div>
          {/* Статичное отображение данных */}
        </div>
      </div>
    )
  }

  // Режим редактирования
  return (
    <Form {...form}>
      <header>
        <h1>Редактирование: {entity.title}</h1>
        <div>
          <Button onClick={handleSave}>Сохранить</Button>
          <Button onClick={handleCancel}>Отмена</Button>
        </div>
      </header>
      <div>
        {/* Поля ввода для редактирования */}
      </div>
    </Form>
  )
}
\`\`\`

### Преимущества

- **Понятное разделение режимов** - пользователь всегда знает, в каком режиме находится
- **Безопасность** - случайные изменения невозможны, требуется явное действие
- **Контекст сохраняется** - пользователь остается на той же странице
- **Удобство** - не нужно открывать модальное окно или переходить на другую страницу
- **Производительность** - один компонент вместо двух (просмотр + редактирование)

### Недостатки

- **Переключение режима** - нужно нажать кнопку для каждого изменения
- **Блокировка карточки** - вся карточка блокируется в режиме редактирования
- **Сложность компонента** - один компонент содержит логику двух режимов

### Альтернативные паттерны

#### Field-by-Field Inline Editing
Каждое поле редактируется отдельно, клик на поле делает его редактируемым.

**Когда использовать:** Для часто изменяемых полей (например, статус задачи, приоритет)

**Примеры:** Notion, Airtable, Linear

#### Modal Editing
Кнопка "Редактировать" открывает модальное окно с формой.

**Когда использовать:** Для сложных форм с множеством полей и валидацией

**Примеры:** Старые CRM системы, административные панели

#### Separate Edit Page
Переход на отдельную страницу для редактирования.

**Когда использовать:** Для очень сложных форм с множеством секций

**Примеры:** WordPress admin, старые веб-приложения

### Рекомендации по реализации

1. **Используйте react-hook-form** для управления формой
2. **Загружайте справочники** при переходе в режим редактирования
3. **Показывайте toast уведомления** об успехе/ошибке операций
4. **Подтверждайте отмену** если есть несохраненные изменения
5. **Валидируйте данные** перед отправкой на сервер
6. **Обрабатывайте ошибки** и показывайте понятные сообщения

### Примеры использования в проекте

- `app/(dashboard)/requirements/[id]/page.tsx` - карточка требования
- `app/(dashboard)/organizations/[id]/page.tsx` - карточка организации
- `app/(dashboard)/controls/[id]/page.tsx` - карточка меры защиты
- `app/(dashboard)/risks/[id]/page.tsx` - карточка риска

---

## Вкладки на карточках

Карточки сущностей содержат вкладки для управления связанными данными. Каждая вкладка - это отдельный компонент с собственной логикой загрузки данных и редактирования.

### Принципы

1. **Независимая загрузка данных** - каждая вкладка загружает свои данные через API
2. **Контекстное редактирование** - редактирование происходит прямо на вкладке
3. **Подвкладки для группировки** - используются для разделения данных (например, "Применённые" и "Рекомендуемые")
4. **Статистика** - каждая вкладка показывает статистику по своим данным

### Структура компонента вкладки

\`\`\`tsx
export function EntityRelationTab({ entityId }: { entityId: string }) {
  const [data, setData] = useState<Data[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchData()
  }, [entityId])

  const fetchData = async () => {
    // Загрузка данных через API
  }

  const handleAdd = async (item: Data) => {
    // Добавление элемента
    await fetchData() // Перезагрузка данных
  }

  const handleRemove = async (id: string) => {
    // Удаление элемента
    await fetchData() // Перезагрузка данных
  }

  return (
    <div>
      <Card>
        <CardHeader>
          <CardTitle>Заголовок</CardTitle>
          <Button onClick={handleAdd}>Добавить</Button>
        </CardHeader>
        <CardContent>
          {/* Список элементов */}
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Статистика</CardTitle>
        </CardHeader>
        <CardContent>
          {/* Статистика */}
        </CardContent>
      </Card>
    </div>
  )
}
\`\`\`

---

## Вкладка "Меры/Контроли" (RequirementControlsTab)

### Назначение

Управление мерами защиты, которые удовлетворяют требование. Показывает связь между требованиями и мерами защиты.

### Структура

**Две подвкладки:**

1. **"Применённые меры"** - меры, которые уже привязаны к требованию
2. **"Рекомендуемые меры"** - шаблоны мер из справочника, которые можно применить

### Компонент: `components/requirements/requirement-controls-tab.tsx`

### Функциональность

#### Подвкладка "Применённые меры"

**Отображение:**
- Список привязанных мер защиты
- Для каждой меры показывается:
  - Код меры (например: "КД-01")
  - Тип меры (технический/организационный/физический)
  - Частота проверки (ежедневно/еженедельно/ежемесячно)
  - Признак автоматизации
  - Название и описание меры
  - Тип маппинга (прямой/косвенный/частичный)
  - Процент покрытия требования
  - Примечания к маппингу

**Действия:**
- **Добавить меру** - открывает диалог выбора меры из справочника
- **Удалить меру** - удаляет привязку меры к требованию

**Статистика:**
- Всего мер
- Автоматизированных мер
- Прямых маппингов

**Empty State:**
Если мер нет, показывается:
- Иконка Shield
- Текст "К этому требованию еще не привязаны меры защиты"
- Кнопка "Добавить первую меру"

#### Подвкладка "Рекомендуемые меры"

**Отображение:**
- Компонент `RecommendedTemplatesSection`
- Показывает шаблоны мер из справочника
- Для каждого шаблона показывается:
  - Код шаблона
  - Тип меры
  - Название и описание
  - Кнопка "Применить"

**Действия:**
- **Применить шаблон** - создает меру на основе шаблона и привязывает к требованию

### API Endpoints

**GET /api/requirements/[id]/controls** - получение списка привязанных мер
\`\`\`typescript
Response: {
  data: [
    {
      id: string
      requirementId: string
      controlId: string
      mappingType: "direct" | "indirect" | "partial"
      coveragePercentage: number
      mappingNotes?: string
      control: {
        id: string
        code: string
        title: string
        description: string
        controlType: "technical" | "organizational" | "physical"
        frequency: "daily" | "weekly" | "monthly" | "quarterly" | "annual"
        isAutomated: boolean
      }
    }
  ]
}
\`\`\`

**POST /api/requirements/[id]/controls** - добавление меры к требованию
\`\`\`typescript
Request: {
  controlId: string
  mappingType: "direct" | "indirect" | "partial"
  coveragePercentage: number
  mappingNotes?: string
}
\`\`\`

**DELETE /api/requirements/[id]/controls/[controlId]** - удаление привязки меры

**GET /api/controls** - получение списка всех мер для выбора

### State Management

\`\`\`typescript
const [controls, setControls] = useState<any[]>([]) // Привязанные меры
const [loading, setLoading] = useState(true) // Индикатор загрузки
const [requirement, setRequirement] = useState<any>(null) // Данные требования
const [showAddDialog, setShowAddDialog] = useState(false) // Показ диалога добавления
const [availableControls, setAvailableControls] = useState<any[]>([]) // Доступные меры
\`\`\`

### Режимы исполнения

**Строгий режим (measureMode: "strict"):**
- Организации обязаны использовать только рекомендуемые меры
- Нельзя добавлять свои меры

**Гибкий режим (measureMode: "flexible"):**
- Организации могут добавлять свои меры
- Рекомендуемые меры предлагаются, но не обязательны

Режим отображается через `RequirementModeBadge` в заголовке карточки.

---

## Вкладка "Доказательства" (RequirementEvidenceTab)

### Назначение

Управление доказательствами выполнения требования. Показывает загруженные документы и файлы, подтверждающие выполнение требования.

### Компонент: `components/requirements/requirement-evidence-tab.tsx`

### Функциональность

**Отображение:**
- Список загруженных доказательств
- Для каждого доказательства показывается:
  - Иконка статуса (одобрено/отклонено/на проверке/черновик)
  - Название файла
  - Описание
  - Теги
  - Размер файла
  - Дата загрузки
  - Дата проверки (если проверено)
  - Комментарий проверяющего (если есть)
  - Badge статуса (одобрено/отклонено/на проверке/черновик)

**Действия:**
- **Загрузить доказательство** - открывает диалог загрузки файла
- **Просмотреть** - открывает файл в новой вкладке
- **Скачать** - скачивает файл
- **Удалить** - удаляет доказательство с подтверждением

**Статистика:**
- Всего доказательств
- Одобрено
- На проверке
- Отклонено

**Empty State:**
Если доказательств нет, показывается:
- Иконка FileText
- Текст "К этому требованию еще не загружены доказательства"
- Кнопка "Загрузить первое доказательство"

### API Endpoints

**GET /api/evidence?requirementId=[id]** - получение списка доказательств
\`\`\`typescript
Response: {
  data: [
    {
      id: string
      requirementId: string
      title?: string
      description?: string
      fileName: string
      fileUrl: string
      fileSize: number
      mimeType: string
      status: "draft" | "pending" | "approved" | "rejected"
      tags?: string[]
      uploadedAt: Date
      uploadedBy: string
      reviewedAt?: Date
      reviewedBy?: string
      reviewNotes?: string
    }
  ]
}
\`\`\`

**POST /api/evidence** - загрузка нового доказательства
\`\`\`typescript
Request: FormData {
  file: File
  requirementId: string
  title?: string
  description?: string
  tags?: string[]
}
\`\`\`

**DELETE /api/evidence/[id]** - удаление доказательства

### State Management

\`\`\`typescript
const [evidence, setEvidence] = useState<Evidence[]>([]) // Список доказательств
const [loading, setLoading] = useState(true) // Индикатор загрузки
const [deleteId, setDeleteId] = useState<string | null>(null) // ID удаляемого доказательства
const [deleting, setDeleting] = useState(false) // Процесс удаления
const [requirement, setRequirement] = useState<any>(null) // Данные требования
\`\`\`

### Статусы доказательств

**draft** - Черновик
- Доказательство загружено, но не отправлено на проверку
- Можно редактировать и удалять

**pending** - На проверке
- Доказательство отправлено на проверку
- Ожидает одобрения или отклонения

**approved** - Одобрено
- Доказательство проверено и одобрено
- Подтверждает выполнение требования

**rejected** - Отклонено
- Доказательство проверено и отклонено
- Требуется загрузить новое доказательство

### Режимы исполнения

**Строгий режим (evidenceTypeMode: "strict"):**
- Можно загружать только указанные типы документов
- Типы проверяются при загрузке

**Гибкий режим (evidenceTypeMode: "flexible"):**
- Можно загружать любые типы документов
- Рекомендуемые типы предлагаются, но не обязательны

Режим отображается через `RequirementModeBadge` в заголовке карточки.

---

## Вкладка "Типы доказательств" (RequirementEvidenceTypesTab)

### Назначение

Управление допустимыми типами доказательств для требования. Определяет, какие типы документов можно загружать для подтверждения выполнения требования.

### Структура

**Две подвкладки:**

1. **"Допустимые типы"** - типы, которые уже добавлены к требованию
2. **"Доступные типы"** - типы из справочника, которые можно добавить

### Компонент: `components/requirements/requirement-evidence-types-tab.tsx`

### Функциональность

#### Подвкладка "Допустимые типы"

**Отображение:**
- Список допустимых типов доказательств
- Для каждого типа показывается:
  - Код типа (например: "DOC-POLICY")
  - Иконка типа (если есть)
  - Название типа
  - Описание типа
  - Формат файлов (regex для валидации)

**Действия:**
- **Добавить тип** - переключает на вкладку "Доступные типы"
- **Удалить тип** - удаляет тип из списка допустимых

**Empty State:**
Если типов нет, показывается:
- Иконка FileType
- Текст зависит от режима:
  - **Строгий режим:** "Не указаны допустимые типы доказательств. В строгом режиме это означает, что нельзя загружать доказательства."
  - **Гибкий режим:** "Не указаны рекомендуемые типы доказательств. В гибком режиме можно загружать любые типы."
- Кнопка "Добавить первый тип"

#### Подвкладка "Доступные типы"

**Отображение:**
- Список типов из справочника, которые еще не добавлены
- Для каждого типа показывается:
  - Код типа
  - Иконка типа
  - Название и описание
  - Формат файлов
  - Кнопка "Добавить"

**Действия:**
- **Добавить тип** - добавляет тип в список допустимых

**Empty State:**
Если все типы уже добавлены, показывается:
- Иконка CheckCircle2 (зеленая)
- Текст "Все доступные типы уже добавлены к требованию"

### API Endpoints

**GET /api/requirements/[id]** - получение требования с allowedEvidenceTypeIds
\`\`\`typescript
Response: {
  data: {
    id: string
    allowedEvidenceTypeIds: string[]
    evidenceTypeMode: "strict" | "flexible"
    // ... другие поля
  }
}
\`\`\`

**PATCH /api/requirements/[id]** - обновление allowedEvidenceTypeIds
\`\`\`typescript
Request: {
  allowedEvidenceTypeIds: string[]
}
\`\`\`

**GET /api/dictionaries/evidence-types** - получение справочника типов доказательств
\`\`\`typescript
Response: {
  data: [
    {
      id: string
      code: string
      title: string
      description: string
      icon?: string
      fileFormatRegex?: string
      isActive: boolean
    }
  ]
}
\`\`\`

### State Management

\`\`\`typescript
const [requirement, setRequirement] = useState<any>(null) // Данные требования
const [allowedTypes, setAllowedTypes] = useState<EvidenceType[]>([]) // Допустимые типы
const [allTypes, setAllTypes] = useState<EvidenceType[]>([]) // Все типы из справочника
const [loading, setLoading] = useState(true) // Индикатор загрузки
\`\`\`

### Логика работы

1. **Загрузка данных:**
   - Загружается требование с `allowedEvidenceTypeIds`
   - Загружается справочник всех типов доказательств
   - Фильтруются допустимые типы по `allowedEvidenceTypeIds`

2. **Добавление типа:**
   - Добавляется ID типа в массив `allowedEvidenceTypeIds`
   - Отправляется PATCH запрос на сервер
   - Перезагружаются данные

3. **Удаление типа:**
   - Удаляется ID типа из массива `allowedEvidenceTypeIds`
   - Отправляется PATCH запрос на сервер
   - Перезагружаются данные

### Режимы исполнения

**Строгий режим (evidenceTypeMode: "strict"):**
- Можно загружать ТОЛЬКО указанные типы документов
- Если типов нет, загрузка доказательств невозможна
- Типы проверяются при загрузке файла

**Гибкий режим (evidenceTypeMode: "flexible"):**
- Указанные типы - это рекомендации
- Можно загружать любые типы документов
- Рекомендуемые типы предлагаются в UI, но не обязательны

Режим отображается через `RequirementModeBadge` в заголовке карточки.

---

## Общие принципы вкладок

### 1. Независимая загрузка данных

Каждая вкладка загружает свои данные через API при монтировании компонента:

\`\`\`typescript
useEffect(() => {
  fetchData()
}, [entityId])
\`\`\`

### 2. Перезагрузка после изменений

После добавления/удаления элементов данные перезагружаются:

\`\`\`typescript
const handleAdd = async (item: Data) => {
  await api.add(item)
  await fetchData() // Перезагрузка
}
\`\`\`

### 3. Toast уведомления

Все операции показывают toast уведомления:

\`\`\`typescript
toast({
  title: "Успех",
  description: "Элемент добавлен",
})
\`\`\`

### 4. Empty States

Каждая вкладка имеет понятный empty state с иконкой и кнопкой действия.

### 5. Статистика

Каждая вкладка показывает статистику по своим данным в отдельной карточке.

### 6. Подтверждение удаления

Удаление элементов требует подтверждения через AlertDialog.

---

## Заключение

Паттерн **Toggle Edit Mode with In-Place Editing** обеспечивает:
- Понятный и безопасный UX
- Единообразие интерфейса
- Простоту реализации
- Легкость поддержки

Вкладки на карточках обеспечивают:
- Контекстное редактирование связанных данных
- Независимую загрузку и управление данными
- Понятную статистику и empty states
- Единообразный UX для всех типов связей
